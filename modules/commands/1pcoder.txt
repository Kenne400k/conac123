// T∆∞·ªùng AI v7.0 - All-in-one: Media th√¥ng minh, ph·ªß ƒë·ªãnh, context, mood, c√° nh√¢n h√≥a, Gemini AI, GIF, Lyrics, Meme, QR, Reminder, Playlist, Group, Game, Tool, v.v.

const TUONGS = ["tuong", "t∆∞·ªùng"];
const YOUTUBE_API_KEY = "AIzaSyD16U7WwrIFGOKijx0GR_3hU6p7Ww7JObM";
const GEMINI_API_KEY = "AIzaSyAIrHT8PlzLDfRwV3HAwcTapkILpH322So";
const GEMINI_MODEL = "gemini-2.0-flash";
const GIPHY_KEY = "x2DSDHSAKfI06mgb0ON56fxtp9JAUTuQ";
const THECATAPI_KEY = "live_R3gMhw4dZ9qymWsBCSjbfzmelZpiawsrH4VwR8qmEs316MDjvwcvSMDgWuxkEdK3";
const GENIUS_API_KEY = "YOUR_GENIUS_API_KEY";

const fs = require("fs-extra");
const path = require("path");
const axios = require("axios");
const ytdl = require("@distube/ytdl-core");
const ffmpeg = require("fluent-ffmpeg");
const qs = require("qs");

const DATA_DIR = path.join(__dirname, "../../data");
const TUONG_DIR = path.join(DATA_DIR, "tuong_ai");
const userDataFile = path.join(TUONG_DIR, "user_data.json");
const groupDataFile = path.join(TUONG_DIR, "group_data.json");
const memoriesFile = path.join(TUONG_DIR, "memories.json");
const playlistsFile = path.join(TUONG_DIR, "playlists.json");
const remindersFile = path.join(TUONG_DIR, "reminders.json");
const autoAIFile = path.join(TUONG_DIR, "auto_ai.json");
const TMP_DIR = path.join(__dirname, "ytb_tmp");

[DATA_DIR, TUONG_DIR, TMP_DIR].forEach(dir => fs.ensureDirSync(dir));
[userDataFile, groupDataFile, memoriesFile, playlistsFile, remindersFile, autoAIFile].forEach(file => {
  if (!fs.existsSync(file)) fs.writeFileSync(file, JSON.stringify({}));
});

let userData = require(userDataFile);
let groupData = require(groupDataFile);
let memories = require(memoriesFile);
let playlists = require(playlistsFile);
let reminders = require(remindersFile);
let autoAI = require(autoAIFile);

function saveData(type) {
  try {
    if (type === 'userData') fs.writeFileSync(userDataFile, JSON.stringify(userData, null, 2));
    if (type === 'groupData') fs.writeFileSync(groupDataFile, JSON.stringify(groupData, null, 2));
    if (type === 'memories') fs.writeFileSync(memoriesFile, JSON.stringify(memories, null, 2));
    if (type === 'playlists') fs.writeFileSync(playlistsFile, JSON.stringify(playlists, null, 2));
    if (type === 'reminders') fs.writeFileSync(remindersFile, JSON.stringify(reminders, null, 2));
    if (type === 'autoAI') fs.writeFileSync(autoAIFile, JSON.stringify(autoAI, null, 2));
  } catch (e) { console.error(`L·ªói l∆∞u ${type}:`, e); }
}
function unsign(str) {
  return (str || "")
    .toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9 ]+/g, " ").replace(/\s+/g, " ").trim();
}

// ==== PH√ÇN T√çCH T·ª™ KH√ìA, PH·ª¶ ƒê·ªäNH, MOOD, CONTEXT & INTENT ====
function parseMediaRequest(userMessage, type = "detect") {
  const msg = unsign(userMessage);

  // Ph·ªß ƒë·ªãnh (lo·∫°i tr·ª´)
  const negPhrases = ["kh√¥ng", "ƒë·ª´ng", "lo·∫°i tr·ª´", "tr√°nh", "not", "no"];
  let negKeywords = [];
  let positive = msg;
  negPhrases.forEach(neg => {
    if (msg.includes(neg)) {
      let after = msg.split(neg).pop().replace(/^(g·ª≠i|video|nh·∫°c|clip|gif|meme)/, "").trim();
      if (after && after.length > 1) negKeywords.push(after);
      positive = positive.replace(neg + " " + after, "");
    }
  });

  // Mood/context
  if (/(bu·ªìn|ch√°n|sad|üò≠|üò¢|stress)/.test(userMessage)) return {type: "mp3", query: "nh·∫°c bu·ªìn", mood: "sad"};
  if (/(vui|meme|h√†i|c∆∞·ªùi|happy|üòÜ)/.test(userMessage)) return {type: "mp4", query: "clip h√†i", mood: "happy"};
  if (/(gif|·∫£nh ƒë·ªông)/.test(userMessage)) return {type: "gif", query: positive, negKeywords};
  if (/(qr|qr code)/.test(userMessage)) return {type: "qr", query: positive.match(/qr code (.+)/)?.[1] || ""};

  let req = null;
  if (type === "detect" || type === "video") {
    const videoWords = ["video","clip","youtube","phim","trailer","mv","show"];
    videoWords.forEach(w => { if (positive.includes(w)) req = {type: "mp4", query: positive.split(w).pop().trim()}; });
  }
  if ((type === "detect" || type === "mp3") && !req) {
    const mp3Words = ["nhac","mp3","audio","bai hat","song","music"];
    mp3Words.forEach(w => { if (positive.includes(w)) req = {type: "mp3", query: positive.split(w).pop().trim()}; });
  }
  if ((type === "detect" || type === "image") && !req) {
    const imgWords = ["·∫£nh","anh","h√¨nh","meme","wallpaper"];
    imgWords.forEach(w => { if (positive.includes(w)) req = {type: "img", query: positive.split(w).pop().trim()}; });
  }
  if (req) req.negKeywords = negKeywords;
  return req;
}

async function searchYouTube(query, maxResults = 10, negKeywords = []) {
  try {
    const response = await axios.get(`https://www.googleapis.com/youtube/v3/search`, {
      params: { q: query, key: YOUTUBE_API_KEY, part: "snippet", maxResults, type: "video", order: "relevance", safeSearch: "moderate" }
    });
    let results = response.data.items.map((video, index) => ({
      index: index + 1,
      title: video.snippet.title,
      videoId: video.id.videoId,
      thumbnail: video.snippet.thumbnails.high?.url || video.snippet.thumbnails.default.url,
      url: `https://www.youtube.com/watch?v=${video.id.videoId}`,
      channel: video.snippet.channelTitle,
      publishedAt: video.snippet.publishedAt
    }));
    const keywords = query.split(" ").filter(k=>k.length>1);
    results = results.filter(r => keywords.every(w => r.title.toLowerCase().includes(w)));
    if (negKeywords && negKeywords.length)
      results = results.filter(r => !negKeywords.some(neg => r.title.toLowerCase().includes(neg)));
    return results;
  } catch { return null; }
}

async function downloadYouTubeMp3(url, outPath, maxSeconds = 300) {
  return new Promise(async (resolve, reject) => {
    try {
      const info = await ytdl.getInfo(url);
      const format = ytdl.chooseFormat(info.formats, {quality:"highestaudio",filter:"audioonly"});
      if (!format) return reject("Kh√¥ng t√¨m th·∫•y audio ph√π h·ª£p!");
      const stream = ytdl.downloadFromInfo(info, {format, highWaterMark: 1<<25});
      ffmpeg(stream).audioBitrate(128).audioCodec('libmp3lame').setDuration(maxSeconds).format("mp3")
        .on("end", () => resolve(outPath)).on("error", e => reject(e)).save(outPath);
    } catch (e) { reject(e); }
  });
}
async function downloadYouTubeMp4(url, outPath, maxSeconds = 300, quality = "360p") {
  return new Promise(async (resolve, reject) => {
    try {
      const info = await ytdl.getInfo(url);
      let format = info.formats.find(f => f.itag === 18) || info.formats.find(f => f.qualityLabel === quality && f.container === "mp4");
      if (!format) format = ytdl.chooseFormat(info.formats, {quality:"lowest",filter:"videoandaudio"});
      if (!format) return reject("Kh√¥ng t√¨m th·∫•y video ph√π h·ª£p!");
      const stream = ytdl.downloadFromInfo(info, {format, highWaterMark: 1<<25});
      ffmpeg(stream).setDuration(maxSeconds).videoBitrate(1000).videoCodec('libx264').audioCodec('aac').format("mp4")
        .on("end", () => resolve(outPath)).on("error", e => reject(e)).save(outPath);
    } catch (e) { reject(e); }
  });
}

async function searchGif(query) {
  try {
    const q = encodeURIComponent(query);
    const res = await axios.get(`https://api.giphy.com/v1/gifs/search?${qs.stringify({q, api_key: GIPHY_KEY, limit: 1})}`);
    return res.data.data[0]?.images?.original?.url || null;
  } catch { return null; }
}

async function searchLyrics(song) {
  try {
    return `L·ªùi b√†i h√°t cho "${song}" s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t sau!`;
  } catch { return null; }
}

async function createQrCode(text) {
  return `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(text)}`;
}

async function catImage() {
  try {
    const res = await axios.get("https://api.thecatapi.com/v1/images/search",{headers:{'x-api-key':THECATAPI_KEY}});
    return res.data[0]?.url;
  } catch { return null; }
}

async function getAIResponse(userMessage, userState, memory, context) {
  let prompt = `B·∫°n l√† T∆∞·ªùng AI. Tr·∫£ l·ªùi th·∫≠t NG·∫ÆN G·ªåN (d∆∞·ªõi 20 t·ª´), th√¢n thi·ªán, kh√¥ng nh·∫Øc l·∫°i c√¢u h·ªèi, kh√¥ng di·ªÖn s√¢u, d·ªÖ th∆∞∆°ng t√≠ nh∆∞ ng∆∞·ªùi y√™u.`;
  prompt += "\nTin nh·∫Øn: " + userMessage;
  try {
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`;
    const response = await axios.post(url, {
      contents: [{role:"user",parts:[{text:prompt}]}],
      generationConfig: { temperature: 0.9, topP: 0.95, maxOutputTokens: 1024 }
    }, {timeout: 15000});
    if (response.data?.candidates?.[0]?.content?.parts?.[0]?.text)
      return response.data.candidates[0].content.parts[0].text;
    return "T∆∞·ªùng b·ªã lag nh·∫π, n√≥i l·∫°i th·ª≠ nh√©! üòÖ";
  } catch { return "T∆∞·ªùng ƒëang b·∫≠n, th·ª≠ l·∫°i sau nha! ü§ñüí≠"; }
}

async function sendMedia(api, event, req, quality = "360p") {
  const {threadID, messageID, senderID} = event;
  if (req.type === "mp3" || req.type === "mp4") {
    let videoList = await searchYouTube(req.query, 10, req.negKeywords);
    if (!videoList || !videoList.length) return api.sendMessage("Kh√¥ng t√¨m th·∫•y video ph√π h·ª£p!", threadID, messageID);
    let bestResult = videoList[0];
    const ext = req.type === "mp3" ? "mp3" : "mp4";
    const filePath = path.join(TMP_DIR, `${bestResult.videoId}_${Date.now()}.${ext}`);
    try {
      api.sendMessage(`‚è≥ ƒêang t·∫£i ${req.type==="mp3"?"MP3":"VIDEO"}: ${bestResult.title}\nüîó ${bestResult.url}\nVui l√≤ng ch·ªù...`, threadID, messageID);
      if (req.type === "mp3") await downloadYouTubeMp3(bestResult.url, filePath, 300);
      else await downloadYouTubeMp4(bestResult.url, filePath, 300, quality);
      api.sendMessage({
        body: `‚úÖ ƒê√£ xong!\nüîó Xem: ${bestResult.url}\nFile ƒë√≠nh k√®m b√™n d∆∞·ªõi.`,
        attachment: fs.createReadStream(filePath)
      }, threadID, () => {fs.unlinkSync(filePath);}, messageID);
      if (req.type==="mp3")
        api.sendMessage(`B·∫°n c√≥ mu·ªën xem l·ªùi b√†i h√°t n√†y kh√¥ng? Reply "lyrics" d∆∞·ªõi ƒë√¢y nh√©!`, threadID);
      let userKey = `${threadID}_${senderID}`;
      if (!userData[userKey]) userData[userKey]={music:[],video:[]};
      if (req.type==="mp3") userData[userKey].music?.push(req.query);
      else userData[userKey].video?.push(req.query);
      saveData('userData');
    } catch (e) {
      try{if (fs.existsSync(filePath)) fs.unlinkSync(filePath);}catch{}
      api.sendMessage(`‚ùå L·ªói t·∫£i ${req.type==="mp3"?"nh·∫°c":"video"}! Th·ª≠ t·ª´ kh√≥a kh√°c ho·∫∑c m·∫°ng kh·ªèe h∆°n nh√©!`, threadID, messageID);
    }
    return;
  }
  if (req.type==="gif") {
    const url = await searchGif(req.query);
    if (url) await api.sendMessage({body: `GIF "${req.query}"`, attachment: await axios({url, responseType:"stream"}).then(r=>r.data)}, threadID, messageID);
    else await api.sendMessage("Kh√¥ng t√¨m th·∫•y GIF ph√π h·ª£p!", threadID, messageID);
    return;
  }
  if (req.type==="img" && /(m√®o|cat|meow)/.test(req.query)) {
    const catImg = await catImage();
    if (catImg) await api.sendMessage({body: "·∫¢nh m√®o cho b·∫°n ƒë√¢y üò∏", attachment: await axios({url: catImg, responseType:"stream"}).then(r=>r.data)}, threadID, messageID);
    else await api.sendMessage("Kh√¥ng t√¨m ƒë∆∞·ª£c ·∫£nh m√®o l√∫c n√†y!", threadID, messageID);
    return;
  }
  if (req.type==="qr") {
    const url = await createQrCode(req.query);
    await api.sendMessage({body: `QR cho n·ªôi dung: "${req.query}"`, attachment: await axios({url, responseType:"stream"}).then(r=>r.data)}, threadID, messageID);
    return;
  }
}

async function handleGu(api, event, args, userKey) {
  if (/gu nhac/i.test(args)) {
    const gu = args.replace(/.*gu nhac/i,"").trim();
    userData[userKey].music = gu.split(/,|;/).map(s=>s.trim());
    saveData('userData');
    return api.sendMessage(`T∆∞·ªùng ƒë√£ nh·ªõ gu nh·∫°c c·ªßa b·∫°n: ${userData[userKey].music.join(", ")}`, event.threadID, event.messageID);
  }
}

module.exports.config = {
  name: "tuong",
  version: "7.0.0",
  hasPermssion: 0,
  credits: "PCODER",
  description: "T∆∞·ªùng AI v7 - Media th√¥ng minh, ph·ªß ƒë·ªãnh, context, mood, AI Gemini, GIF, Meme, QR, lyrics, reminder, playlist, group, game, tool, ALL-IN-ONE!",
  commandCategory: "ai",
  usages: [
    "tuong [n·ªôi dung] - Chat AI, media, tool, meme, game, group, playlist, reminder, ...",
    "g·ª≠i video/nh·∫°c/gif/·∫£nh/meme/qr [t·ª´ kh√≥a] - t·∫£i v√† g·ª≠i media",
    "tuong set gu nhac edm, nhac tre - ƒë·∫∑t s·ªü th√≠ch nh·∫°c",
    "tuong nh·∫Øc t√¥i u·ªëng n∆∞·ªõc sau 2h - nh·∫Øc nh·ªü c√° nh√¢n",
    "tuong t·∫°o qr hello world - t·∫°o QR code",
    "tuong gif happy - g·ª≠i gif vui",
    "tuong lyrics [b√†i h√°t] - t√¨m l·ªùi b√†i h√°t"
  ],
  cooldowns: 2,
  dependencies: {
    "axios": "",
    "fs-extra": "",
    "@distube/ytdl-core": "",
    "fluent-ffmpeg": "",
    "qs":""
  }
};

module.exports.onLoad = async () => {
  console.log("ü§ñ T∆∞·ªùng AI v7.0 ƒë√£ s·∫µn s√†ng!");
  setInterval(() => {
    if (global.client.handleReply) {
      const now = Date.now();
      global.client.handleReply = global.client.handleReply.filter(r => !r.expires || r.expires > now);
    }
  }, 300000);
};

module.exports.handleEvent = async function({ api, event, args }) {
  const {threadID, messageID, senderID, body = "", attachments = [] } = event;
  const userKey = `${threadID}_${senderID}`;
  if (!userData[userKey]) userData[userKey] = {music:[],video:[],gu:{},xungho:"b·∫°n",nick:"",mood:"vui v·∫ª",memory:[]};

  // == ON/OFF AUTO AI (b·∫≠t t·∫Øt t·ª± ƒë·ªông tr·∫£ l·ªùi nh√≥m) ==
  const bodyLower = body.toLowerCase();
  const messageStartsWithTuong = TUONGS.some(t => bodyLower.startsWith(t));
  if (messageStartsWithTuong && /\b(on|off)\b/.test(bodyLower)) {
    if (/\bon\b/.test(bodyLower)) {
      autoAI[threadID] = true; saveData('autoAI');
      return api.sendMessage("üü¢ ƒê√£ b·∫≠t ch·∫ø ƒë·ªô t·ª± ƒë·ªông tr·∫£ l·ªùi cho nh√≥m n√†y! T∆∞·ªùng s·∫Ω tr·∫£ l·ªùi m·ªçi tin nh·∫Øn.", threadID, messageID);
    } else if (/\boff\b/.test(bodyLower)) {
      autoAI[threadID] = false; saveData('autoAI');
      return api.sendMessage("üî¥ ƒê√£ t·∫Øt ch·∫ø ƒë·ªô t·ª± ƒë·ªông cho nh√≥m n√†y. G·ªçi 'T∆∞·ªùng' th√¨ T∆∞·ªùng m·ªõi tr·∫£ l·ªùi nha!", threadID, messageID);
    }
  }

  // == CH·ªà PH·∫¢N H·ªíI KHI ON HO·∫∂C G·ªåI T√äN ==
  const messageContainsTuong = TUONGS.some(t => bodyLower.includes(t));
  if (autoAI[threadID] !== true && !messageContainsTuong && attachments.length === 0) return;

  // 1. Tr·∫£ l·ªùi gu c√° nh√¢n h√≥a
  if (/set gu/i.test(body)) return handleGu(api, event, body, userKey);

  // 2. Parse media/intent
  const req = parseMediaRequest(body, "detect");
  if (req) return sendMedia(api, event, req);

  // 3. Lyrics
  if (/lyrics |loi bai hat/.test(body)) {
    const song = body.replace(/.*lyrics|loi bai hat/i,"").trim();
    const lyric = await searchLyrics(song);
    return api.sendMessage(lyric, threadID, messageID);
  }

  // 4. QR code
  if (/t·∫°o qr|qr code/i.test(body)) {
    const qrTxt = body.replace(/.*qr code|t·∫°o qr/i,"").trim();
    const url = await createQrCode(qrTxt);
    return api.sendMessage({body:`QR cho: ${qrTxt}`, attachment: await axios({url, responseType:"stream"}).then(r=>r.data)}, threadID, messageID);
  }

  // 5. ·∫¢nh meme m√®o
  if (/meme|cat|m√®o/i.test(body) && /(·∫£nh|g·ª≠i|show|meme)/i.test(body)) {
    const catImg = await catImage();
    if (catImg)
      return api.sendMessage({body:"·∫¢nh meme m√®o cho b·∫°n üò∏",attachment: await axios({url:catImg,responseType:"stream"}).then(r=>r.data)},threadID,messageID);
  }

  // 6. Chat Gemini AI (default)
  userData[userKey].memory.push({time:Date.now(),text:body});
  if (userData[userKey].memory.length>10) userData[userKey].memory.shift();
  const reply = await getAIResponse(body, userData[userKey], userData[userKey].memory, "");
  await api.sendMessage(reply, threadID, messageID);
  saveData('userData');
};

module.exports.handleReply = async function ({ api, event, handleReply }) {
  const { threadID, messageID, senderID, body } = event;
  // Lyrics
  if (/lyrics|l·ªùi b√†i h√°t/i.test(body)) {
    const idx = handleReply.lastIndex || 0;
    const video = handleReply.videoList[idx];
    if (video) {
      const lyric = await searchLyrics(video.title);
      await api.sendMessage(lyric, threadID, messageID);
    }
    return;
  }
  // Media choices
  if (/video kh√°c|random/i.test(body)) {
    await sendMedia(api, {threadID,messageID,senderID}, handleReply.req, handleReply.quality);
    return;
  }
};

module.exports.run = async function({ api, event, args }) {
  return this.handleEvent({ api, event, args });
};